// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aisaaccommand.proto

#ifndef PROTOBUF_INCLUDED_aisaaccommand_2eproto
#define PROTOBUF_INCLUDED_aisaaccommand_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_aisaaccommand_2eproto 

namespace protobuf_aisaaccommand_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_aisaaccommand_2eproto
namespace aisaacpb {
class Acceleration;
class AccelerationDefaultTypeInternal;
extern AccelerationDefaultTypeInternal _Acceleration_default_instance_;
class Dribble;
class DribbleDefaultTypeInternal;
extern DribbleDefaultTypeInternal _Dribble_default_instance_;
class Kick;
class KickDefaultTypeInternal;
extern KickDefaultTypeInternal _Kick_default_instance_;
class Obstacle;
class ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class RaspiCommand;
class RaspiCommandDefaultTypeInternal;
extern RaspiCommandDefaultTypeInternal _RaspiCommand_default_instance_;
class SpcCommand;
class SpcCommandDefaultTypeInternal;
extern SpcCommandDefaultTypeInternal _SpcCommand_default_instance_;
class Velocity;
class VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
class VisionData;
class VisionDataDefaultTypeInternal;
extern VisionDataDefaultTypeInternal _VisionData_default_instance_;
}  // namespace aisaacpb
namespace google {
namespace protobuf {
template<> ::aisaacpb::Acceleration* Arena::CreateMaybeMessage<::aisaacpb::Acceleration>(Arena*);
template<> ::aisaacpb::Dribble* Arena::CreateMaybeMessage<::aisaacpb::Dribble>(Arena*);
template<> ::aisaacpb::Kick* Arena::CreateMaybeMessage<::aisaacpb::Kick>(Arena*);
template<> ::aisaacpb::Obstacle* Arena::CreateMaybeMessage<::aisaacpb::Obstacle>(Arena*);
template<> ::aisaacpb::Position* Arena::CreateMaybeMessage<::aisaacpb::Position>(Arena*);
template<> ::aisaacpb::RaspiCommand* Arena::CreateMaybeMessage<::aisaacpb::RaspiCommand>(Arena*);
template<> ::aisaacpb::SpcCommand* Arena::CreateMaybeMessage<::aisaacpb::SpcCommand>(Arena*);
template<> ::aisaacpb::Velocity* Arena::CreateMaybeMessage<::aisaacpb::Velocity>(Arena*);
template<> ::aisaacpb::VisionData* Arena::CreateMaybeMessage<::aisaacpb::VisionData>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace aisaacpb {

enum Kick_KickType {
  Kick_KickType_None = 0,
  Kick_KickType_Force = 1,
  Kick_KickType_Sensor = 2,
  Kick_KickType_XY = 3,
  Kick_KickType_Kick_KickType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Kick_KickType_Kick_KickType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Kick_KickType_IsValid(int value);
const Kick_KickType Kick_KickType_KickType_MIN = Kick_KickType_None;
const Kick_KickType Kick_KickType_KickType_MAX = Kick_KickType_XY;
const int Kick_KickType_KickType_ARRAYSIZE = Kick_KickType_KickType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Kick_KickType_descriptor();
inline const ::std::string& Kick_KickType_Name(Kick_KickType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Kick_KickType_descriptor(), value);
}
inline bool Kick_KickType_Parse(
    const ::std::string& name, Kick_KickType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Kick_KickType>(
    Kick_KickType_descriptor(), name, value);
}
enum Kick_KickMethod {
  Kick_KickMethod_Chip = 0,
  Kick_KickMethod_Straight = 1,
  Kick_KickMethod_Kick_KickMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Kick_KickMethod_Kick_KickMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Kick_KickMethod_IsValid(int value);
const Kick_KickMethod Kick_KickMethod_KickMethod_MIN = Kick_KickMethod_Chip;
const Kick_KickMethod Kick_KickMethod_KickMethod_MAX = Kick_KickMethod_Straight;
const int Kick_KickMethod_KickMethod_ARRAYSIZE = Kick_KickMethod_KickMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Kick_KickMethod_descriptor();
inline const ::std::string& Kick_KickMethod_Name(Kick_KickMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Kick_KickMethod_descriptor(), value);
}
inline bool Kick_KickMethod_Parse(
    const ::std::string& name, Kick_KickMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Kick_KickMethod>(
    Kick_KickMethod_descriptor(), name, value);
}
enum RobotCommandCoordinateSystemType {
  Vector = 0,
  Coordinate = 1,
  Relax = 2,
  RobotCommandCoordinateSystemType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RobotCommandCoordinateSystemType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RobotCommandCoordinateSystemType_IsValid(int value);
const RobotCommandCoordinateSystemType RobotCommandCoordinateSystemType_MIN = Vector;
const RobotCommandCoordinateSystemType RobotCommandCoordinateSystemType_MAX = Relax;
const int RobotCommandCoordinateSystemType_ARRAYSIZE = RobotCommandCoordinateSystemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotCommandCoordinateSystemType_descriptor();
inline const ::std::string& RobotCommandCoordinateSystemType_Name(RobotCommandCoordinateSystemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotCommandCoordinateSystemType_descriptor(), value);
}
inline bool RobotCommandCoordinateSystemType_Parse(
    const ::std::string& name, RobotCommandCoordinateSystemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotCommandCoordinateSystemType>(
    RobotCommandCoordinateSystemType_descriptor(), name, value);
}
// ===================================================================

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(NULL);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // int32 theta = 3;
  void clear_theta();
  static const int kThetaFieldNumber = 3;
  ::google::protobuf::int32 theta() const;
  void set_theta(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aisaacpb.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 theta_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Velocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.Velocity) */ {
 public:
  Velocity();
  virtual ~Velocity();

  Velocity(const Velocity& from);

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Velocity(Velocity&& from) noexcept
    : Velocity() {
    *this = ::std::move(from);
  }

  inline Velocity& operator=(Velocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Velocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Velocity* internal_default_instance() {
    return reinterpret_cast<const Velocity*>(
               &_Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Velocity* other);
  friend void swap(Velocity& a, Velocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Velocity* New() const final {
    return CreateMaybeMessage<Velocity>(NULL);
  }

  Velocity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Velocity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Velocity& from);
  void MergeFrom(const Velocity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Velocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 vx = 1;
  void clear_vx();
  static const int kVxFieldNumber = 1;
  ::google::protobuf::int32 vx() const;
  void set_vx(::google::protobuf::int32 value);

  // int32 vy = 2;
  void clear_vy();
  static const int kVyFieldNumber = 2;
  ::google::protobuf::int32 vy() const;
  void set_vy(::google::protobuf::int32 value);

  // int32 omega = 3;
  void clear_omega();
  static const int kOmegaFieldNumber = 3;
  ::google::protobuf::int32 omega() const;
  void set_omega(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aisaacpb.Velocity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 vx_;
  ::google::protobuf::int32 vy_;
  ::google::protobuf::int32 omega_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Acceleration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.Acceleration) */ {
 public:
  Acceleration();
  virtual ~Acceleration();

  Acceleration(const Acceleration& from);

  inline Acceleration& operator=(const Acceleration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Acceleration(Acceleration&& from) noexcept
    : Acceleration() {
    *this = ::std::move(from);
  }

  inline Acceleration& operator=(Acceleration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Acceleration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Acceleration* internal_default_instance() {
    return reinterpret_cast<const Acceleration*>(
               &_Acceleration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Acceleration* other);
  friend void swap(Acceleration& a, Acceleration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Acceleration* New() const final {
    return CreateMaybeMessage<Acceleration>(NULL);
  }

  Acceleration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Acceleration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Acceleration& from);
  void MergeFrom(const Acceleration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Acceleration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 ax = 1;
  void clear_ax();
  static const int kAxFieldNumber = 1;
  ::google::protobuf::int32 ax() const;
  void set_ax(::google::protobuf::int32 value);

  // int32 ay = 2;
  void clear_ay();
  static const int kAyFieldNumber = 2;
  ::google::protobuf::int32 ay() const;
  void set_ay(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aisaacpb.Acceleration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ax_;
  ::google::protobuf::int32 ay_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Obstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.Obstacle) */ {
 public:
  Obstacle();
  virtual ~Obstacle();

  Obstacle(const Obstacle& from);

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Obstacle(Obstacle&& from) noexcept
    : Obstacle() {
    *this = ::std::move(from);
  }

  inline Obstacle& operator=(Obstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Obstacle* internal_default_instance() {
    return reinterpret_cast<const Obstacle*>(
               &_Obstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Obstacle* other);
  friend void swap(Obstacle& a, Obstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Obstacle* New() const final {
    return CreateMaybeMessage<Obstacle>(NULL);
  }

  Obstacle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Obstacle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // int32 theta = 3;
  void clear_theta();
  static const int kThetaFieldNumber = 3;
  ::google::protobuf::int32 theta() const;
  void set_theta(::google::protobuf::int32 value);

  // int32 vx = 4;
  void clear_vx();
  static const int kVxFieldNumber = 4;
  ::google::protobuf::int32 vx() const;
  void set_vx(::google::protobuf::int32 value);

  // int32 vy = 5;
  void clear_vy();
  static const int kVyFieldNumber = 5;
  ::google::protobuf::int32 vy() const;
  void set_vy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aisaacpb.Obstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 theta_;
  ::google::protobuf::int32 vx_;
  ::google::protobuf::int32 vy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Kick : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.Kick) */ {
 public:
  Kick();
  virtual ~Kick();

  Kick(const Kick& from);

  inline Kick& operator=(const Kick& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Kick(Kick&& from) noexcept
    : Kick() {
    *this = ::std::move(from);
  }

  inline Kick& operator=(Kick&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Kick& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Kick* internal_default_instance() {
    return reinterpret_cast<const Kick*>(
               &_Kick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Kick* other);
  friend void swap(Kick& a, Kick& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Kick* New() const final {
    return CreateMaybeMessage<Kick>(NULL);
  }

  Kick* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Kick>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Kick& from);
  void MergeFrom(const Kick& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Kick* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Kick_KickType KickType;
  static const KickType None =
    Kick_KickType_None;
  static const KickType Force =
    Kick_KickType_Force;
  static const KickType Sensor =
    Kick_KickType_Sensor;
  static const KickType XY =
    Kick_KickType_XY;
  static inline bool KickType_IsValid(int value) {
    return Kick_KickType_IsValid(value);
  }
  static const KickType KickType_MIN =
    Kick_KickType_KickType_MIN;
  static const KickType KickType_MAX =
    Kick_KickType_KickType_MAX;
  static const int KickType_ARRAYSIZE =
    Kick_KickType_KickType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KickType_descriptor() {
    return Kick_KickType_descriptor();
  }
  static inline const ::std::string& KickType_Name(KickType value) {
    return Kick_KickType_Name(value);
  }
  static inline bool KickType_Parse(const ::std::string& name,
      KickType* value) {
    return Kick_KickType_Parse(name, value);
  }

  typedef Kick_KickMethod KickMethod;
  static const KickMethod Chip =
    Kick_KickMethod_Chip;
  static const KickMethod Straight =
    Kick_KickMethod_Straight;
  static inline bool KickMethod_IsValid(int value) {
    return Kick_KickMethod_IsValid(value);
  }
  static const KickMethod KickMethod_MIN =
    Kick_KickMethod_KickMethod_MIN;
  static const KickMethod KickMethod_MAX =
    Kick_KickMethod_KickMethod_MAX;
  static const int KickMethod_ARRAYSIZE =
    Kick_KickMethod_KickMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KickMethod_descriptor() {
    return Kick_KickMethod_descriptor();
  }
  static inline const ::std::string& KickMethod_Name(KickMethod value) {
    return Kick_KickMethod_Name(value);
  }
  static inline bool KickMethod_Parse(const ::std::string& name,
      KickMethod* value) {
    return Kick_KickMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .aisaacpb.Position ball_goal = 6;
  bool has_ball_goal() const;
  void clear_ball_goal();
  static const int kBallGoalFieldNumber = 6;
  private:
  const ::aisaacpb::Position& _internal_ball_goal() const;
  public:
  const ::aisaacpb::Position& ball_goal() const;
  ::aisaacpb::Position* release_ball_goal();
  ::aisaacpb::Position* mutable_ball_goal();
  void set_allocated_ball_goal(::aisaacpb::Position* ball_goal);

  // int32 kick_power = 3;
  void clear_kick_power();
  static const int kKickPowerFieldNumber = 3;
  ::google::protobuf::int32 kick_power() const;
  void set_kick_power(::google::protobuf::int32 value);

  // bool ball_kick_state = 1;
  void clear_ball_kick_state();
  static const int kBallKickStateFieldNumber = 1;
  bool ball_kick_state() const;
  void set_ball_kick_state(bool value);

  // bool ball_kick = 2;
  void clear_ball_kick();
  static const int kBallKickFieldNumber = 2;
  bool ball_kick() const;
  void set_ball_kick(bool value);

  // bool ball_kick_active = 4;
  void clear_ball_kick_active();
  static const int kBallKickActiveFieldNumber = 4;
  bool ball_kick_active() const;
  void set_ball_kick_active(bool value);

  // bool free_kick_flag = 5;
  void clear_free_kick_flag();
  static const int kFreeKickFlagFieldNumber = 5;
  bool free_kick_flag() const;
  void set_free_kick_flag(bool value);

  // int32 ball_target_allowable_error = 7;
  void clear_ball_target_allowable_error();
  static const int kBallTargetAllowableErrorFieldNumber = 7;
  ::google::protobuf::int32 ball_target_allowable_error() const;
  void set_ball_target_allowable_error(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aisaacpb.Kick)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::aisaacpb::Position* ball_goal_;
  ::google::protobuf::int32 kick_power_;
  bool ball_kick_state_;
  bool ball_kick_;
  bool ball_kick_active_;
  bool free_kick_flag_;
  ::google::protobuf::int32 ball_target_allowable_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dribble : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.Dribble) */ {
 public:
  Dribble();
  virtual ~Dribble();

  Dribble(const Dribble& from);

  inline Dribble& operator=(const Dribble& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dribble(Dribble&& from) noexcept
    : Dribble() {
    *this = ::std::move(from);
  }

  inline Dribble& operator=(Dribble&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dribble& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dribble* internal_default_instance() {
    return reinterpret_cast<const Dribble*>(
               &_Dribble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Dribble* other);
  friend void swap(Dribble& a, Dribble& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dribble* New() const final {
    return CreateMaybeMessage<Dribble>(NULL);
  }

  Dribble* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dribble>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Dribble& from);
  void MergeFrom(const Dribble& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dribble* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aisaacpb.Position dribble_goal = 4;
  bool has_dribble_goal() const;
  void clear_dribble_goal();
  static const int kDribbleGoalFieldNumber = 4;
  private:
  const ::aisaacpb::Position& _internal_dribble_goal() const;
  public:
  const ::aisaacpb::Position& dribble_goal() const;
  ::aisaacpb::Position* release_dribble_goal();
  ::aisaacpb::Position* mutable_dribble_goal();
  void set_allocated_dribble_goal(::aisaacpb::Position* dribble_goal);

  // double dribble_power = 1;
  void clear_dribble_power();
  static const int kDribblePowerFieldNumber = 1;
  double dribble_power() const;
  void set_dribble_power(double value);

  // bool dribble_state = 2;
  void clear_dribble_state();
  static const int kDribbleStateFieldNumber = 2;
  bool dribble_state() const;
  void set_dribble_state(bool value);

  // bool dribbler_active = 3;
  void clear_dribbler_active();
  static const int kDribblerActiveFieldNumber = 3;
  bool dribbler_active() const;
  void set_dribbler_active(bool value);

  // int32 dribble_complete_distance = 5;
  void clear_dribble_complete_distance();
  static const int kDribbleCompleteDistanceFieldNumber = 5;
  ::google::protobuf::int32 dribble_complete_distance() const;
  void set_dribble_complete_distance(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aisaacpb.Dribble)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::aisaacpb::Position* dribble_goal_;
  double dribble_power_;
  bool dribble_state_;
  bool dribbler_active_;
  ::google::protobuf::int32 dribble_complete_distance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpcCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.SpcCommand) */ {
 public:
  SpcCommand();
  virtual ~SpcCommand();

  SpcCommand(const SpcCommand& from);

  inline SpcCommand& operator=(const SpcCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpcCommand(SpcCommand&& from) noexcept
    : SpcCommand() {
    *this = ::std::move(from);
  }

  inline SpcCommand& operator=(SpcCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpcCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpcCommand* internal_default_instance() {
    return reinterpret_cast<const SpcCommand*>(
               &_SpcCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SpcCommand* other);
  friend void swap(SpcCommand& a, SpcCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpcCommand* New() const final {
    return CreateMaybeMessage<SpcCommand>(NULL);
  }

  SpcCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpcCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpcCommand& from);
  void MergeFrom(const SpcCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpcCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aisaacpb.Position goal_pose = 2;
  bool has_goal_pose() const;
  void clear_goal_pose();
  static const int kGoalPoseFieldNumber = 2;
  private:
  const ::aisaacpb::Position& _internal_goal_pose() const;
  public:
  const ::aisaacpb::Position& goal_pose() const;
  ::aisaacpb::Position* release_goal_pose();
  ::aisaacpb::Position* mutable_goal_pose();
  void set_allocated_goal_pose(::aisaacpb::Position* goal_pose);

  // .aisaacpb.Position middle_goal_pose = 5;
  bool has_middle_goal_pose() const;
  void clear_middle_goal_pose();
  static const int kMiddleGoalPoseFieldNumber = 5;
  private:
  const ::aisaacpb::Position& _internal_middle_goal_pose() const;
  public:
  const ::aisaacpb::Position& middle_goal_pose() const;
  ::aisaacpb::Position* release_middle_goal_pose();
  ::aisaacpb::Position* mutable_middle_goal_pose();
  void set_allocated_middle_goal_pose(::aisaacpb::Position* middle_goal_pose);

  // .aisaacpb.Dribble dribble = 6;
  bool has_dribble() const;
  void clear_dribble();
  static const int kDribbleFieldNumber = 6;
  private:
  const ::aisaacpb::Dribble& _internal_dribble() const;
  public:
  const ::aisaacpb::Dribble& dribble() const;
  ::aisaacpb::Dribble* release_dribble();
  ::aisaacpb::Dribble* mutable_dribble();
  void set_allocated_dribble(::aisaacpb::Dribble* dribble);

  // .aisaacpb.Kick kick = 7;
  bool has_kick() const;
  void clear_kick();
  static const int kKickFieldNumber = 7;
  private:
  const ::aisaacpb::Kick& _internal_kick() const;
  public:
  const ::aisaacpb::Kick& kick() const;
  ::aisaacpb::Kick* release_kick();
  ::aisaacpb::Kick* mutable_kick();
  void set_allocated_kick(::aisaacpb::Kick* kick);

  // .aisaacpb.RobotCommandCoordinateSystemType robot_command_type = 1;
  void clear_robot_command_type();
  static const int kRobotCommandTypeFieldNumber = 1;
  ::aisaacpb::RobotCommandCoordinateSystemType robot_command_type() const;
  void set_robot_command_type(::aisaacpb::RobotCommandCoordinateSystemType value);

  // bool prohibited_zone_ignore = 3;
  void clear_prohibited_zone_ignore();
  static const int kProhibitedZoneIgnoreFieldNumber = 3;
  bool prohibited_zone_ignore() const;
  void set_prohibited_zone_ignore(bool value);

  // bool middle_target_flag = 4;
  void clear_middle_target_flag();
  static const int kMiddleTargetFlagFieldNumber = 4;
  bool middle_target_flag() const;
  void set_middle_target_flag(bool value);

  // @@protoc_insertion_point(class_scope:aisaacpb.SpcCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::aisaacpb::Position* goal_pose_;
  ::aisaacpb::Position* middle_goal_pose_;
  ::aisaacpb::Dribble* dribble_;
  ::aisaacpb::Kick* kick_;
  int robot_command_type_;
  bool prohibited_zone_ignore_;
  bool middle_target_flag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RaspiCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.RaspiCommand) */ {
 public:
  RaspiCommand();
  virtual ~RaspiCommand();

  RaspiCommand(const RaspiCommand& from);

  inline RaspiCommand& operator=(const RaspiCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RaspiCommand(RaspiCommand&& from) noexcept
    : RaspiCommand() {
    *this = ::std::move(from);
  }

  inline RaspiCommand& operator=(RaspiCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RaspiCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RaspiCommand* internal_default_instance() {
    return reinterpret_cast<const RaspiCommand*>(
               &_RaspiCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RaspiCommand* other);
  friend void swap(RaspiCommand& a, RaspiCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RaspiCommand* New() const final {
    return CreateMaybeMessage<RaspiCommand>(NULL);
  }

  RaspiCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RaspiCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RaspiCommand& from);
  void MergeFrom(const RaspiCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaspiCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aisaacpb.Velocity goal_pose_velocity = 2;
  bool has_goal_pose_velocity() const;
  void clear_goal_pose_velocity();
  static const int kGoalPoseVelocityFieldNumber = 2;
  private:
  const ::aisaacpb::Velocity& _internal_goal_pose_velocity() const;
  public:
  const ::aisaacpb::Velocity& goal_pose_velocity() const;
  ::aisaacpb::Velocity* release_goal_pose_velocity();
  ::aisaacpb::Velocity* mutable_goal_pose_velocity();
  void set_allocated_goal_pose_velocity(::aisaacpb::Velocity* goal_pose_velocity);

  // .aisaacpb.Dribble dribble = 3;
  bool has_dribble() const;
  void clear_dribble();
  static const int kDribbleFieldNumber = 3;
  private:
  const ::aisaacpb::Dribble& _internal_dribble() const;
  public:
  const ::aisaacpb::Dribble& dribble() const;
  ::aisaacpb::Dribble* release_dribble();
  ::aisaacpb::Dribble* mutable_dribble();
  void set_allocated_dribble(::aisaacpb::Dribble* dribble);

  // .aisaacpb.Kick kick = 4;
  bool has_kick() const;
  void clear_kick();
  static const int kKickFieldNumber = 4;
  private:
  const ::aisaacpb::Kick& _internal_kick() const;
  public:
  const ::aisaacpb::Kick& kick() const;
  ::aisaacpb::Kick* release_kick();
  ::aisaacpb::Kick* mutable_kick();
  void set_allocated_kick(::aisaacpb::Kick* kick);

  // .aisaacpb.RobotCommandCoordinateSystemType robot_command_type = 1;
  void clear_robot_command_type();
  static const int kRobotCommandTypeFieldNumber = 1;
  ::aisaacpb::RobotCommandCoordinateSystemType robot_command_type() const;
  void set_robot_command_type(::aisaacpb::RobotCommandCoordinateSystemType value);

  // @@protoc_insertion_point(class_scope:aisaacpb.RaspiCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::aisaacpb::Velocity* goal_pose_velocity_;
  ::aisaacpb::Dribble* dribble_;
  ::aisaacpb::Kick* kick_;
  int robot_command_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VisionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aisaacpb.VisionData) */ {
 public:
  VisionData();
  virtual ~VisionData();

  VisionData(const VisionData& from);

  inline VisionData& operator=(const VisionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VisionData(VisionData&& from) noexcept
    : VisionData() {
    *this = ::std::move(from);
  }

  inline VisionData& operator=(VisionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VisionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VisionData* internal_default_instance() {
    return reinterpret_cast<const VisionData*>(
               &_VisionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(VisionData* other);
  friend void swap(VisionData& a, VisionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VisionData* New() const final {
    return CreateMaybeMessage<VisionData>(NULL);
  }

  VisionData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VisionData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VisionData& from);
  void MergeFrom(const VisionData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aisaacpb.Obstacle obstacles = 3;
  int obstacles_size() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 3;
  ::aisaacpb::Obstacle* mutable_obstacles(int index);
  ::google::protobuf::RepeatedPtrField< ::aisaacpb::Obstacle >*
      mutable_obstacles();
  const ::aisaacpb::Obstacle& obstacles(int index) const;
  ::aisaacpb::Obstacle* add_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::aisaacpb::Obstacle >&
      obstacles() const;

  // .aisaacpb.Position own_machine_position = 1;
  bool has_own_machine_position() const;
  void clear_own_machine_position();
  static const int kOwnMachinePositionFieldNumber = 1;
  private:
  const ::aisaacpb::Position& _internal_own_machine_position() const;
  public:
  const ::aisaacpb::Position& own_machine_position() const;
  ::aisaacpb::Position* release_own_machine_position();
  ::aisaacpb::Position* mutable_own_machine_position();
  void set_allocated_own_machine_position(::aisaacpb::Position* own_machine_position);

  // .aisaacpb.Position ball_position = 2;
  bool has_ball_position() const;
  void clear_ball_position();
  static const int kBallPositionFieldNumber = 2;
  private:
  const ::aisaacpb::Position& _internal_ball_position() const;
  public:
  const ::aisaacpb::Position& ball_position() const;
  ::aisaacpb::Position* release_ball_position();
  ::aisaacpb::Position* mutable_ball_position();
  void set_allocated_ball_position(::aisaacpb::Position* ball_position);

  // @@protoc_insertion_point(class_scope:aisaacpb.VisionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aisaacpb::Obstacle > obstacles_;
  ::aisaacpb::Position* own_machine_position_;
  ::aisaacpb::Position* ball_position_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_aisaaccommand_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position

// int32 x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Position::x() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Position.x)
  return x_;
}
inline void Position::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Position.x)
}

// int32 y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Position::y() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Position.y)
  return y_;
}
inline void Position::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Position.y)
}

// int32 theta = 3;
inline void Position::clear_theta() {
  theta_ = 0;
}
inline ::google::protobuf::int32 Position::theta() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Position.theta)
  return theta_;
}
inline void Position::set_theta(::google::protobuf::int32 value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Position.theta)
}

// -------------------------------------------------------------------

// Velocity

// int32 vx = 1;
inline void Velocity::clear_vx() {
  vx_ = 0;
}
inline ::google::protobuf::int32 Velocity::vx() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Velocity.vx)
  return vx_;
}
inline void Velocity::set_vx(::google::protobuf::int32 value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Velocity.vx)
}

// int32 vy = 2;
inline void Velocity::clear_vy() {
  vy_ = 0;
}
inline ::google::protobuf::int32 Velocity::vy() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Velocity.vy)
  return vy_;
}
inline void Velocity::set_vy(::google::protobuf::int32 value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Velocity.vy)
}

// int32 omega = 3;
inline void Velocity::clear_omega() {
  omega_ = 0;
}
inline ::google::protobuf::int32 Velocity::omega() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Velocity.omega)
  return omega_;
}
inline void Velocity::set_omega(::google::protobuf::int32 value) {
  
  omega_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Velocity.omega)
}

// -------------------------------------------------------------------

// Acceleration

// int32 ax = 1;
inline void Acceleration::clear_ax() {
  ax_ = 0;
}
inline ::google::protobuf::int32 Acceleration::ax() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Acceleration.ax)
  return ax_;
}
inline void Acceleration::set_ax(::google::protobuf::int32 value) {
  
  ax_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Acceleration.ax)
}

// int32 ay = 2;
inline void Acceleration::clear_ay() {
  ay_ = 0;
}
inline ::google::protobuf::int32 Acceleration::ay() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Acceleration.ay)
  return ay_;
}
inline void Acceleration::set_ay(::google::protobuf::int32 value) {
  
  ay_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Acceleration.ay)
}

// -------------------------------------------------------------------

// Obstacle

// int32 x = 1;
inline void Obstacle::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Obstacle::x() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Obstacle.x)
  return x_;
}
inline void Obstacle::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Obstacle.x)
}

// int32 y = 2;
inline void Obstacle::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Obstacle::y() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Obstacle.y)
  return y_;
}
inline void Obstacle::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Obstacle.y)
}

// int32 theta = 3;
inline void Obstacle::clear_theta() {
  theta_ = 0;
}
inline ::google::protobuf::int32 Obstacle::theta() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Obstacle.theta)
  return theta_;
}
inline void Obstacle::set_theta(::google::protobuf::int32 value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Obstacle.theta)
}

// int32 vx = 4;
inline void Obstacle::clear_vx() {
  vx_ = 0;
}
inline ::google::protobuf::int32 Obstacle::vx() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Obstacle.vx)
  return vx_;
}
inline void Obstacle::set_vx(::google::protobuf::int32 value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Obstacle.vx)
}

// int32 vy = 5;
inline void Obstacle::clear_vy() {
  vy_ = 0;
}
inline ::google::protobuf::int32 Obstacle::vy() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Obstacle.vy)
  return vy_;
}
inline void Obstacle::set_vy(::google::protobuf::int32 value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Obstacle.vy)
}

// -------------------------------------------------------------------

// Kick

// bool ball_kick_state = 1;
inline void Kick::clear_ball_kick_state() {
  ball_kick_state_ = false;
}
inline bool Kick::ball_kick_state() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Kick.ball_kick_state)
  return ball_kick_state_;
}
inline void Kick::set_ball_kick_state(bool value) {
  
  ball_kick_state_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Kick.ball_kick_state)
}

// bool ball_kick = 2;
inline void Kick::clear_ball_kick() {
  ball_kick_ = false;
}
inline bool Kick::ball_kick() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Kick.ball_kick)
  return ball_kick_;
}
inline void Kick::set_ball_kick(bool value) {
  
  ball_kick_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Kick.ball_kick)
}

// int32 kick_power = 3;
inline void Kick::clear_kick_power() {
  kick_power_ = 0;
}
inline ::google::protobuf::int32 Kick::kick_power() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Kick.kick_power)
  return kick_power_;
}
inline void Kick::set_kick_power(::google::protobuf::int32 value) {
  
  kick_power_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Kick.kick_power)
}

// bool ball_kick_active = 4;
inline void Kick::clear_ball_kick_active() {
  ball_kick_active_ = false;
}
inline bool Kick::ball_kick_active() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Kick.ball_kick_active)
  return ball_kick_active_;
}
inline void Kick::set_ball_kick_active(bool value) {
  
  ball_kick_active_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Kick.ball_kick_active)
}

// bool free_kick_flag = 5;
inline void Kick::clear_free_kick_flag() {
  free_kick_flag_ = false;
}
inline bool Kick::free_kick_flag() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Kick.free_kick_flag)
  return free_kick_flag_;
}
inline void Kick::set_free_kick_flag(bool value) {
  
  free_kick_flag_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Kick.free_kick_flag)
}

// .aisaacpb.Position ball_goal = 6;
inline bool Kick::has_ball_goal() const {
  return this != internal_default_instance() && ball_goal_ != NULL;
}
inline void Kick::clear_ball_goal() {
  if (GetArenaNoVirtual() == NULL && ball_goal_ != NULL) {
    delete ball_goal_;
  }
  ball_goal_ = NULL;
}
inline const ::aisaacpb::Position& Kick::_internal_ball_goal() const {
  return *ball_goal_;
}
inline const ::aisaacpb::Position& Kick::ball_goal() const {
  const ::aisaacpb::Position* p = ball_goal_;
  // @@protoc_insertion_point(field_get:aisaacpb.Kick.ball_goal)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Position*>(
      &::aisaacpb::_Position_default_instance_);
}
inline ::aisaacpb::Position* Kick::release_ball_goal() {
  // @@protoc_insertion_point(field_release:aisaacpb.Kick.ball_goal)
  
  ::aisaacpb::Position* temp = ball_goal_;
  ball_goal_ = NULL;
  return temp;
}
inline ::aisaacpb::Position* Kick::mutable_ball_goal() {
  
  if (ball_goal_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Position>(GetArenaNoVirtual());
    ball_goal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.Kick.ball_goal)
  return ball_goal_;
}
inline void Kick::set_allocated_ball_goal(::aisaacpb::Position* ball_goal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ball_goal_;
  }
  if (ball_goal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ball_goal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ball_goal, submessage_arena);
    }
    
  } else {
    
  }
  ball_goal_ = ball_goal;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.Kick.ball_goal)
}

// int32 ball_target_allowable_error = 7;
inline void Kick::clear_ball_target_allowable_error() {
  ball_target_allowable_error_ = 0;
}
inline ::google::protobuf::int32 Kick::ball_target_allowable_error() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Kick.ball_target_allowable_error)
  return ball_target_allowable_error_;
}
inline void Kick::set_ball_target_allowable_error(::google::protobuf::int32 value) {
  
  ball_target_allowable_error_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Kick.ball_target_allowable_error)
}

// -------------------------------------------------------------------

// Dribble

// double dribble_power = 1;
inline void Dribble::clear_dribble_power() {
  dribble_power_ = 0;
}
inline double Dribble::dribble_power() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Dribble.dribble_power)
  return dribble_power_;
}
inline void Dribble::set_dribble_power(double value) {
  
  dribble_power_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Dribble.dribble_power)
}

// bool dribble_state = 2;
inline void Dribble::clear_dribble_state() {
  dribble_state_ = false;
}
inline bool Dribble::dribble_state() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Dribble.dribble_state)
  return dribble_state_;
}
inline void Dribble::set_dribble_state(bool value) {
  
  dribble_state_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Dribble.dribble_state)
}

// bool dribbler_active = 3;
inline void Dribble::clear_dribbler_active() {
  dribbler_active_ = false;
}
inline bool Dribble::dribbler_active() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Dribble.dribbler_active)
  return dribbler_active_;
}
inline void Dribble::set_dribbler_active(bool value) {
  
  dribbler_active_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Dribble.dribbler_active)
}

// .aisaacpb.Position dribble_goal = 4;
inline bool Dribble::has_dribble_goal() const {
  return this != internal_default_instance() && dribble_goal_ != NULL;
}
inline void Dribble::clear_dribble_goal() {
  if (GetArenaNoVirtual() == NULL && dribble_goal_ != NULL) {
    delete dribble_goal_;
  }
  dribble_goal_ = NULL;
}
inline const ::aisaacpb::Position& Dribble::_internal_dribble_goal() const {
  return *dribble_goal_;
}
inline const ::aisaacpb::Position& Dribble::dribble_goal() const {
  const ::aisaacpb::Position* p = dribble_goal_;
  // @@protoc_insertion_point(field_get:aisaacpb.Dribble.dribble_goal)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Position*>(
      &::aisaacpb::_Position_default_instance_);
}
inline ::aisaacpb::Position* Dribble::release_dribble_goal() {
  // @@protoc_insertion_point(field_release:aisaacpb.Dribble.dribble_goal)
  
  ::aisaacpb::Position* temp = dribble_goal_;
  dribble_goal_ = NULL;
  return temp;
}
inline ::aisaacpb::Position* Dribble::mutable_dribble_goal() {
  
  if (dribble_goal_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Position>(GetArenaNoVirtual());
    dribble_goal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.Dribble.dribble_goal)
  return dribble_goal_;
}
inline void Dribble::set_allocated_dribble_goal(::aisaacpb::Position* dribble_goal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dribble_goal_;
  }
  if (dribble_goal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dribble_goal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dribble_goal, submessage_arena);
    }
    
  } else {
    
  }
  dribble_goal_ = dribble_goal;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.Dribble.dribble_goal)
}

// int32 dribble_complete_distance = 5;
inline void Dribble::clear_dribble_complete_distance() {
  dribble_complete_distance_ = 0;
}
inline ::google::protobuf::int32 Dribble::dribble_complete_distance() const {
  // @@protoc_insertion_point(field_get:aisaacpb.Dribble.dribble_complete_distance)
  return dribble_complete_distance_;
}
inline void Dribble::set_dribble_complete_distance(::google::protobuf::int32 value) {
  
  dribble_complete_distance_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.Dribble.dribble_complete_distance)
}

// -------------------------------------------------------------------

// SpcCommand

// .aisaacpb.RobotCommandCoordinateSystemType robot_command_type = 1;
inline void SpcCommand::clear_robot_command_type() {
  robot_command_type_ = 0;
}
inline ::aisaacpb::RobotCommandCoordinateSystemType SpcCommand::robot_command_type() const {
  // @@protoc_insertion_point(field_get:aisaacpb.SpcCommand.robot_command_type)
  return static_cast< ::aisaacpb::RobotCommandCoordinateSystemType >(robot_command_type_);
}
inline void SpcCommand::set_robot_command_type(::aisaacpb::RobotCommandCoordinateSystemType value) {
  
  robot_command_type_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.SpcCommand.robot_command_type)
}

// .aisaacpb.Position goal_pose = 2;
inline bool SpcCommand::has_goal_pose() const {
  return this != internal_default_instance() && goal_pose_ != NULL;
}
inline void SpcCommand::clear_goal_pose() {
  if (GetArenaNoVirtual() == NULL && goal_pose_ != NULL) {
    delete goal_pose_;
  }
  goal_pose_ = NULL;
}
inline const ::aisaacpb::Position& SpcCommand::_internal_goal_pose() const {
  return *goal_pose_;
}
inline const ::aisaacpb::Position& SpcCommand::goal_pose() const {
  const ::aisaacpb::Position* p = goal_pose_;
  // @@protoc_insertion_point(field_get:aisaacpb.SpcCommand.goal_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Position*>(
      &::aisaacpb::_Position_default_instance_);
}
inline ::aisaacpb::Position* SpcCommand::release_goal_pose() {
  // @@protoc_insertion_point(field_release:aisaacpb.SpcCommand.goal_pose)
  
  ::aisaacpb::Position* temp = goal_pose_;
  goal_pose_ = NULL;
  return temp;
}
inline ::aisaacpb::Position* SpcCommand::mutable_goal_pose() {
  
  if (goal_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Position>(GetArenaNoVirtual());
    goal_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.SpcCommand.goal_pose)
  return goal_pose_;
}
inline void SpcCommand::set_allocated_goal_pose(::aisaacpb::Position* goal_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete goal_pose_;
  }
  if (goal_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      goal_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, goal_pose, submessage_arena);
    }
    
  } else {
    
  }
  goal_pose_ = goal_pose;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.SpcCommand.goal_pose)
}

// bool prohibited_zone_ignore = 3;
inline void SpcCommand::clear_prohibited_zone_ignore() {
  prohibited_zone_ignore_ = false;
}
inline bool SpcCommand::prohibited_zone_ignore() const {
  // @@protoc_insertion_point(field_get:aisaacpb.SpcCommand.prohibited_zone_ignore)
  return prohibited_zone_ignore_;
}
inline void SpcCommand::set_prohibited_zone_ignore(bool value) {
  
  prohibited_zone_ignore_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.SpcCommand.prohibited_zone_ignore)
}

// bool middle_target_flag = 4;
inline void SpcCommand::clear_middle_target_flag() {
  middle_target_flag_ = false;
}
inline bool SpcCommand::middle_target_flag() const {
  // @@protoc_insertion_point(field_get:aisaacpb.SpcCommand.middle_target_flag)
  return middle_target_flag_;
}
inline void SpcCommand::set_middle_target_flag(bool value) {
  
  middle_target_flag_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.SpcCommand.middle_target_flag)
}

// .aisaacpb.Position middle_goal_pose = 5;
inline bool SpcCommand::has_middle_goal_pose() const {
  return this != internal_default_instance() && middle_goal_pose_ != NULL;
}
inline void SpcCommand::clear_middle_goal_pose() {
  if (GetArenaNoVirtual() == NULL && middle_goal_pose_ != NULL) {
    delete middle_goal_pose_;
  }
  middle_goal_pose_ = NULL;
}
inline const ::aisaacpb::Position& SpcCommand::_internal_middle_goal_pose() const {
  return *middle_goal_pose_;
}
inline const ::aisaacpb::Position& SpcCommand::middle_goal_pose() const {
  const ::aisaacpb::Position* p = middle_goal_pose_;
  // @@protoc_insertion_point(field_get:aisaacpb.SpcCommand.middle_goal_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Position*>(
      &::aisaacpb::_Position_default_instance_);
}
inline ::aisaacpb::Position* SpcCommand::release_middle_goal_pose() {
  // @@protoc_insertion_point(field_release:aisaacpb.SpcCommand.middle_goal_pose)
  
  ::aisaacpb::Position* temp = middle_goal_pose_;
  middle_goal_pose_ = NULL;
  return temp;
}
inline ::aisaacpb::Position* SpcCommand::mutable_middle_goal_pose() {
  
  if (middle_goal_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Position>(GetArenaNoVirtual());
    middle_goal_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.SpcCommand.middle_goal_pose)
  return middle_goal_pose_;
}
inline void SpcCommand::set_allocated_middle_goal_pose(::aisaacpb::Position* middle_goal_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete middle_goal_pose_;
  }
  if (middle_goal_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      middle_goal_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, middle_goal_pose, submessage_arena);
    }
    
  } else {
    
  }
  middle_goal_pose_ = middle_goal_pose;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.SpcCommand.middle_goal_pose)
}

// .aisaacpb.Dribble dribble = 6;
inline bool SpcCommand::has_dribble() const {
  return this != internal_default_instance() && dribble_ != NULL;
}
inline void SpcCommand::clear_dribble() {
  if (GetArenaNoVirtual() == NULL && dribble_ != NULL) {
    delete dribble_;
  }
  dribble_ = NULL;
}
inline const ::aisaacpb::Dribble& SpcCommand::_internal_dribble() const {
  return *dribble_;
}
inline const ::aisaacpb::Dribble& SpcCommand::dribble() const {
  const ::aisaacpb::Dribble* p = dribble_;
  // @@protoc_insertion_point(field_get:aisaacpb.SpcCommand.dribble)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Dribble*>(
      &::aisaacpb::_Dribble_default_instance_);
}
inline ::aisaacpb::Dribble* SpcCommand::release_dribble() {
  // @@protoc_insertion_point(field_release:aisaacpb.SpcCommand.dribble)
  
  ::aisaacpb::Dribble* temp = dribble_;
  dribble_ = NULL;
  return temp;
}
inline ::aisaacpb::Dribble* SpcCommand::mutable_dribble() {
  
  if (dribble_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Dribble>(GetArenaNoVirtual());
    dribble_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.SpcCommand.dribble)
  return dribble_;
}
inline void SpcCommand::set_allocated_dribble(::aisaacpb::Dribble* dribble) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dribble_;
  }
  if (dribble) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dribble = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dribble, submessage_arena);
    }
    
  } else {
    
  }
  dribble_ = dribble;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.SpcCommand.dribble)
}

// .aisaacpb.Kick kick = 7;
inline bool SpcCommand::has_kick() const {
  return this != internal_default_instance() && kick_ != NULL;
}
inline void SpcCommand::clear_kick() {
  if (GetArenaNoVirtual() == NULL && kick_ != NULL) {
    delete kick_;
  }
  kick_ = NULL;
}
inline const ::aisaacpb::Kick& SpcCommand::_internal_kick() const {
  return *kick_;
}
inline const ::aisaacpb::Kick& SpcCommand::kick() const {
  const ::aisaacpb::Kick* p = kick_;
  // @@protoc_insertion_point(field_get:aisaacpb.SpcCommand.kick)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Kick*>(
      &::aisaacpb::_Kick_default_instance_);
}
inline ::aisaacpb::Kick* SpcCommand::release_kick() {
  // @@protoc_insertion_point(field_release:aisaacpb.SpcCommand.kick)
  
  ::aisaacpb::Kick* temp = kick_;
  kick_ = NULL;
  return temp;
}
inline ::aisaacpb::Kick* SpcCommand::mutable_kick() {
  
  if (kick_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Kick>(GetArenaNoVirtual());
    kick_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.SpcCommand.kick)
  return kick_;
}
inline void SpcCommand::set_allocated_kick(::aisaacpb::Kick* kick) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kick_;
  }
  if (kick) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kick = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kick, submessage_arena);
    }
    
  } else {
    
  }
  kick_ = kick;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.SpcCommand.kick)
}

// -------------------------------------------------------------------

// RaspiCommand

// .aisaacpb.RobotCommandCoordinateSystemType robot_command_type = 1;
inline void RaspiCommand::clear_robot_command_type() {
  robot_command_type_ = 0;
}
inline ::aisaacpb::RobotCommandCoordinateSystemType RaspiCommand::robot_command_type() const {
  // @@protoc_insertion_point(field_get:aisaacpb.RaspiCommand.robot_command_type)
  return static_cast< ::aisaacpb::RobotCommandCoordinateSystemType >(robot_command_type_);
}
inline void RaspiCommand::set_robot_command_type(::aisaacpb::RobotCommandCoordinateSystemType value) {
  
  robot_command_type_ = value;
  // @@protoc_insertion_point(field_set:aisaacpb.RaspiCommand.robot_command_type)
}

// .aisaacpb.Velocity goal_pose_velocity = 2;
inline bool RaspiCommand::has_goal_pose_velocity() const {
  return this != internal_default_instance() && goal_pose_velocity_ != NULL;
}
inline void RaspiCommand::clear_goal_pose_velocity() {
  if (GetArenaNoVirtual() == NULL && goal_pose_velocity_ != NULL) {
    delete goal_pose_velocity_;
  }
  goal_pose_velocity_ = NULL;
}
inline const ::aisaacpb::Velocity& RaspiCommand::_internal_goal_pose_velocity() const {
  return *goal_pose_velocity_;
}
inline const ::aisaacpb::Velocity& RaspiCommand::goal_pose_velocity() const {
  const ::aisaacpb::Velocity* p = goal_pose_velocity_;
  // @@protoc_insertion_point(field_get:aisaacpb.RaspiCommand.goal_pose_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Velocity*>(
      &::aisaacpb::_Velocity_default_instance_);
}
inline ::aisaacpb::Velocity* RaspiCommand::release_goal_pose_velocity() {
  // @@protoc_insertion_point(field_release:aisaacpb.RaspiCommand.goal_pose_velocity)
  
  ::aisaacpb::Velocity* temp = goal_pose_velocity_;
  goal_pose_velocity_ = NULL;
  return temp;
}
inline ::aisaacpb::Velocity* RaspiCommand::mutable_goal_pose_velocity() {
  
  if (goal_pose_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Velocity>(GetArenaNoVirtual());
    goal_pose_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.RaspiCommand.goal_pose_velocity)
  return goal_pose_velocity_;
}
inline void RaspiCommand::set_allocated_goal_pose_velocity(::aisaacpb::Velocity* goal_pose_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete goal_pose_velocity_;
  }
  if (goal_pose_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      goal_pose_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, goal_pose_velocity, submessage_arena);
    }
    
  } else {
    
  }
  goal_pose_velocity_ = goal_pose_velocity;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.RaspiCommand.goal_pose_velocity)
}

// .aisaacpb.Dribble dribble = 3;
inline bool RaspiCommand::has_dribble() const {
  return this != internal_default_instance() && dribble_ != NULL;
}
inline void RaspiCommand::clear_dribble() {
  if (GetArenaNoVirtual() == NULL && dribble_ != NULL) {
    delete dribble_;
  }
  dribble_ = NULL;
}
inline const ::aisaacpb::Dribble& RaspiCommand::_internal_dribble() const {
  return *dribble_;
}
inline const ::aisaacpb::Dribble& RaspiCommand::dribble() const {
  const ::aisaacpb::Dribble* p = dribble_;
  // @@protoc_insertion_point(field_get:aisaacpb.RaspiCommand.dribble)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Dribble*>(
      &::aisaacpb::_Dribble_default_instance_);
}
inline ::aisaacpb::Dribble* RaspiCommand::release_dribble() {
  // @@protoc_insertion_point(field_release:aisaacpb.RaspiCommand.dribble)
  
  ::aisaacpb::Dribble* temp = dribble_;
  dribble_ = NULL;
  return temp;
}
inline ::aisaacpb::Dribble* RaspiCommand::mutable_dribble() {
  
  if (dribble_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Dribble>(GetArenaNoVirtual());
    dribble_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.RaspiCommand.dribble)
  return dribble_;
}
inline void RaspiCommand::set_allocated_dribble(::aisaacpb::Dribble* dribble) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dribble_;
  }
  if (dribble) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dribble = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dribble, submessage_arena);
    }
    
  } else {
    
  }
  dribble_ = dribble;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.RaspiCommand.dribble)
}

// .aisaacpb.Kick kick = 4;
inline bool RaspiCommand::has_kick() const {
  return this != internal_default_instance() && kick_ != NULL;
}
inline void RaspiCommand::clear_kick() {
  if (GetArenaNoVirtual() == NULL && kick_ != NULL) {
    delete kick_;
  }
  kick_ = NULL;
}
inline const ::aisaacpb::Kick& RaspiCommand::_internal_kick() const {
  return *kick_;
}
inline const ::aisaacpb::Kick& RaspiCommand::kick() const {
  const ::aisaacpb::Kick* p = kick_;
  // @@protoc_insertion_point(field_get:aisaacpb.RaspiCommand.kick)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Kick*>(
      &::aisaacpb::_Kick_default_instance_);
}
inline ::aisaacpb::Kick* RaspiCommand::release_kick() {
  // @@protoc_insertion_point(field_release:aisaacpb.RaspiCommand.kick)
  
  ::aisaacpb::Kick* temp = kick_;
  kick_ = NULL;
  return temp;
}
inline ::aisaacpb::Kick* RaspiCommand::mutable_kick() {
  
  if (kick_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Kick>(GetArenaNoVirtual());
    kick_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.RaspiCommand.kick)
  return kick_;
}
inline void RaspiCommand::set_allocated_kick(::aisaacpb::Kick* kick) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kick_;
  }
  if (kick) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kick = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kick, submessage_arena);
    }
    
  } else {
    
  }
  kick_ = kick;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.RaspiCommand.kick)
}

// -------------------------------------------------------------------

// VisionData

// .aisaacpb.Position own_machine_position = 1;
inline bool VisionData::has_own_machine_position() const {
  return this != internal_default_instance() && own_machine_position_ != NULL;
}
inline void VisionData::clear_own_machine_position() {
  if (GetArenaNoVirtual() == NULL && own_machine_position_ != NULL) {
    delete own_machine_position_;
  }
  own_machine_position_ = NULL;
}
inline const ::aisaacpb::Position& VisionData::_internal_own_machine_position() const {
  return *own_machine_position_;
}
inline const ::aisaacpb::Position& VisionData::own_machine_position() const {
  const ::aisaacpb::Position* p = own_machine_position_;
  // @@protoc_insertion_point(field_get:aisaacpb.VisionData.own_machine_position)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Position*>(
      &::aisaacpb::_Position_default_instance_);
}
inline ::aisaacpb::Position* VisionData::release_own_machine_position() {
  // @@protoc_insertion_point(field_release:aisaacpb.VisionData.own_machine_position)
  
  ::aisaacpb::Position* temp = own_machine_position_;
  own_machine_position_ = NULL;
  return temp;
}
inline ::aisaacpb::Position* VisionData::mutable_own_machine_position() {
  
  if (own_machine_position_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Position>(GetArenaNoVirtual());
    own_machine_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.VisionData.own_machine_position)
  return own_machine_position_;
}
inline void VisionData::set_allocated_own_machine_position(::aisaacpb::Position* own_machine_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete own_machine_position_;
  }
  if (own_machine_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      own_machine_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, own_machine_position, submessage_arena);
    }
    
  } else {
    
  }
  own_machine_position_ = own_machine_position;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.VisionData.own_machine_position)
}

// .aisaacpb.Position ball_position = 2;
inline bool VisionData::has_ball_position() const {
  return this != internal_default_instance() && ball_position_ != NULL;
}
inline void VisionData::clear_ball_position() {
  if (GetArenaNoVirtual() == NULL && ball_position_ != NULL) {
    delete ball_position_;
  }
  ball_position_ = NULL;
}
inline const ::aisaacpb::Position& VisionData::_internal_ball_position() const {
  return *ball_position_;
}
inline const ::aisaacpb::Position& VisionData::ball_position() const {
  const ::aisaacpb::Position* p = ball_position_;
  // @@protoc_insertion_point(field_get:aisaacpb.VisionData.ball_position)
  return p != NULL ? *p : *reinterpret_cast<const ::aisaacpb::Position*>(
      &::aisaacpb::_Position_default_instance_);
}
inline ::aisaacpb::Position* VisionData::release_ball_position() {
  // @@protoc_insertion_point(field_release:aisaacpb.VisionData.ball_position)
  
  ::aisaacpb::Position* temp = ball_position_;
  ball_position_ = NULL;
  return temp;
}
inline ::aisaacpb::Position* VisionData::mutable_ball_position() {
  
  if (ball_position_ == NULL) {
    auto* p = CreateMaybeMessage<::aisaacpb::Position>(GetArenaNoVirtual());
    ball_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aisaacpb.VisionData.ball_position)
  return ball_position_;
}
inline void VisionData::set_allocated_ball_position(::aisaacpb::Position* ball_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ball_position_;
  }
  if (ball_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ball_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ball_position, submessage_arena);
    }
    
  } else {
    
  }
  ball_position_ = ball_position;
  // @@protoc_insertion_point(field_set_allocated:aisaacpb.VisionData.ball_position)
}

// repeated .aisaacpb.Obstacle obstacles = 3;
inline int VisionData::obstacles_size() const {
  return obstacles_.size();
}
inline void VisionData::clear_obstacles() {
  obstacles_.Clear();
}
inline ::aisaacpb::Obstacle* VisionData::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:aisaacpb.VisionData.obstacles)
  return obstacles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aisaacpb::Obstacle >*
VisionData::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:aisaacpb.VisionData.obstacles)
  return &obstacles_;
}
inline const ::aisaacpb::Obstacle& VisionData::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:aisaacpb.VisionData.obstacles)
  return obstacles_.Get(index);
}
inline ::aisaacpb::Obstacle* VisionData::add_obstacles() {
  // @@protoc_insertion_point(field_add:aisaacpb.VisionData.obstacles)
  return obstacles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aisaacpb::Obstacle >&
VisionData::obstacles() const {
  // @@protoc_insertion_point(field_list:aisaacpb.VisionData.obstacles)
  return obstacles_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace aisaacpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aisaacpb::Kick_KickType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aisaacpb::Kick_KickType>() {
  return ::aisaacpb::Kick_KickType_descriptor();
}
template <> struct is_proto_enum< ::aisaacpb::Kick_KickMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aisaacpb::Kick_KickMethod>() {
  return ::aisaacpb::Kick_KickMethod_descriptor();
}
template <> struct is_proto_enum< ::aisaacpb::RobotCommandCoordinateSystemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aisaacpb::RobotCommandCoordinateSystemType>() {
  return ::aisaacpb::RobotCommandCoordinateSystemType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_aisaaccommand_2eproto
